<header>
    <hgroup>
        <h2>Community App Sharing Architecture</h2>
        <h1>Relay Module</h1>
    </hgroup>
</header>

<footer>
    
    <section>
        <h1>Status of this Memo</h1>
        <p>This memorandum specifies the CASA Protocol Relay Module, which defines how to make inter-system queries to retrieve payloads and then publish those payloads inter-system. The specification outlined forthwith is a work in progress and not intended for production use at this time. Distribution of this memo is unlimited.</p>
    </section>
    
    <section>
        <h1>Copyright Notice</h1>
        <p>Copyright (c) 2013, Regents of the University of California. All rights reserved.</p>
    </section>
    
    <section>
        
        <h1>Requirements</h1>
        
        <p>The following specifications must be implemented with this module:</p>
        
        <dl>
            <dt><a href="core">CASA Protocol Core</a></dt>
            <dd>Must implement basic protocol definition.</dd>
            <dt><a href="module/payload#transitpayload">CASA Protocol Payload Module - TransitPayload</a></dt>
            <dd>Must implement TransitPayload with journal attribute.</dd>
            <dt><a href="module/payload#localpayload">CASA Protocol Payload Module - LocalPayload</a></dt>
            <dd>Must implement LocalPayload with original attribute and journal attribute.</dd>
            <dt><a href="module/publisher#sendout">CASA Protocol Publisher Module - SendOut</a></dt>
            <dd>Must implement SendOut; may implement with access control.</dd>
            <dt><a href="module/receiver#receivein">CASA Protocol Receiver Module - ReceiveIn</a></dt>
            <dd>Must implement ReceiveIn; may implement with access control.</dd>
            <dt><a href="module/receiver#adjintranslate">CASA Protocol Receiver Module - AdjInTranslate</a></dt>
            <dd>Must implement AdjInTranslate.</dd>
            <dt><a href="module/receiver#adjinsquash">CASA Protocol Receiver Module - AdjInSquash</a></dt>
            <dd>Must implement AdjInSquash.</dd>
            <dt><a href="module/receiver#adjinsquash">CASA Protocol Receiver Module - AdjInFilter</a></dt>
            <dd>Must implement AdjInFilter; may implement with custom rules.</dd>
            <dt><a href="module/receiver#adjinstore">CASA Protocol Receiver Module - AdjInStore</a></dt>
            <dd>Must implement AdjInStore.</dd>
        </dl>
        
    </section>
    
    <section>
        
        <h1>Terminology</h1>
        <p>The key words <strong>must</strong>, <strong>must not</strong>, <strong>required</strong>, <strong>shall</strong>, <strong>shall not</strong>, <strong>should</strong>, <strong>should not</strong>, <strong>recommended</strong>, <strong>may</strong>, and <strong>optional</strong> in this document are to be interpreted as described by <strong><a href="http://tools.ietf.org/rfc/rfc2119.txt" rel="external">RFC 2119</a></strong> ["Key words for use in RFCs to Indicate Requirement Levels"].</p>
        
    </section>
    
</footer>

<main>
    
    <section data-requirement="must">
        
        <h1>Data Path</h1>
        
        <p>To receive a payload received as described by the <a href="module/receiver">Receiver Module</a>:</p>
        
        <ol>
            <li>Create empty array for payloads response.</li>
            <li>
                For each payload from <a href="module/receiver#adjinstore"><var>AdjInStore::get()</var> (Receiver Module)</a> or <a href="module/local#localstore"><var>LocalStore::get()</var> (Local Module)</a>:
                <ol>
                    <li>Must transform attributes via <a href="#adjouttransform"><var>AdjOutTransform</var></a>; may transform with custom rules;</li>
                    <li>May store within <a href="#adjoutstore">AdjOutStore</a>;</li>
                    <li>Must pass filtering by <a href="#adjoutfilter"><var>AdjOutFilter</var></a>; may filter with custom rules;</li>
                    <li>Must translate via <a href="#adjouttranslate">AdjOutTranslate</a>;</li>
                    <li>Should append to payloads response array</li>
                </ol>
            </li>
            <li>Send payloads response array via <a href="module/publisher#sendout"><var>SendOut</var> (Publisher Module)</a>.</li>
        </ol>
        
        <p>Upon successful completion of this data path, a system shall have produced a set of valid <a href="module/payloads#transitpayload"><var>TransitPayload</var> (Payload Module)</a> objects for inter-system retrieval by a peering system.</p>
        
    </section>
    
    <section data-requirement="must">
        
        <h1>AdjOutTransform</h1>
        
        <p>The <dfn>AdjOutTransform</dfn> operation makes changes to all payloads before they are shared outbound. This operation must be performed over any payload before it may be conveyed beyond the boundaries of the system.</p>
        
        <section data-status="conflict" data-message="By implication, this section is in conflict with <a href='module/payload#transitpayload-attributes'><var>TransitPayload.attributes</var> (Payload Module)</a> because it does nothing to remove the <var>attributes</var> section that is marked as 'should not' under the other module. It is likely that the 'should not' classification should be changed to 'may' rather than this section adjusted, as there's no good reason for not allowing its inclusion.">
            
            <p>This operation must perform the following transformations:</p>
        
            <ol>
                <li>If <var>original</var> section is not defined, it must be created as a copy of the <var>attributes</var> section.</li>
                <li>If <var>attributes.propagate</var> is <var>false</var>, the value of <var>attributes.share</var> must be set <var>false</var>.</li>
            </ol>
            
            <p>An implementation may define additional criteria for this operation.</p>
            
        </section>
            
        <section data-requirement="must" data-status="stub">
            
            <h1>AdjOutTransformJournal</h1>
            
        </section>

    </section>
    
    <section data-requirement="may">
        
        <h1>AdjOutStore</h1>
        
        <p>The <dfn>AdjOutStore</dfn> structure is a persistent data store that contains <a href='module/payloads#localpayload'><var>LocalPayload</var> (Payload Module)</a> objects. A payload stored in this structure must first have been processed through <a href='#adjouttransform'><var>AdjOutTransform</var></a>.</p>
        
        <p data-status='non-normative'>Payloads arrive at this structure via the <a href="#data-path">data path</a> from either <a href="module/receiver#adjinstore"><var>AdjInStore</var> (Receiver Module)</a> or <a href="module/local#localstore"><var>LocalStore</var> (Local Module)</a>.</p>
        
        <section data-requirement='must'>
            
            <h1>Required Operations</h1>
        
            <p>This structure must support two operations:</p>

            <dl>
                <dt data-ref='adjinstore-create'>AdjOutStore::create(LocalPayload)</dt>
                <dd>Stores a new record in persistence; must not create a record if any record already exists in persistence with the same <var>identity</var> as the new record.</dd>
                <dt data-ref='adjinstore-get'>AdjOutStore::get(PayloadIdentity)</dt>
                <dd>Gets a record from persistence that matches the <a href='module/payload#payloadidentity'><var>PayloadIdentity</var> (Payload Module)</a> passed to this method, or if no identity is passed, returns all payloads; must return false if identity was specified and no payload exists matching identity.</dd>
            </dl>
        
            <p data-status='non-normative'>This structure will not store two payloads with identical <var>identity</var> sections.</p>
            
            <p>The <var>create</var> operation must not be used in any way except as defined by this protocol and its modules.</p>
            
            <p data-status='non-normative'>To add a payload for propagation via <a href='module/publisher#sendout'><var>SendOut</var> (Publisher Module)</a>, it must originate from <var>AdjInStore</var> or <var>LocalStore</var>. It must not be added directly to <var>AdjOutStore</var>, as this would imply that the payload neither originated locally nor was propagated from another system.</p>
        
        </section>
        
        <section data-requirement='should'>
            
            <h1>Additional Operations</h1>
        
            <p>This structure should support two additional operations:</p>
        
            <dl>
                <dt data-ref='adjinstore-update'>AdjOutStore::update(LocalPayload)</dt>
                <dd>Updates an existing payload record in persistence; must identify the payload to update by finding an existing record in persistence with the same <var>identity</var> attribute.</dd>
                <dt data-ref='adjinstore-get'>AdjOutStore::delete(PayloadIdentity)</dt>
                <dd>Deletes a record from persistence that matches the <a href='module/payload#payloadidentity'><var>PayloadIdentity</var> (Payload Module)</a> passed to this method.</dd>
            </dl>
            
            <p>The <var>update</var> and <var>delete</var> operations must not be used in any way except as defined by this protocol and its modules.</p>
            
            <p data-status='non-normative'>To change the way a payload is presented via <a href='module/publisher#sendout'><var>SendOut</var> (Publisher Module)</a>, use <a href='#adjouttransform'><var>AdjOutTransform</var></a>. A payload must never be updated directly within this structure.</p>
        
            <p>The <var>delete</var> operation should be used to prune out stale entries.</p>
            
            <p data-status='non-normative'>To prevent a payload from being presented via <a href='module/publisher#sendout'><var>SendOut</var> (Publisher Module)</a>, use <a href='#adjoutfilter'><var>AdjOutFilter</var></a>. A payload must not be prevented from being presented by <var>AdjOutStore::delete()</var>.</p>
        
    </section>
    
    <section data-requirement="must">
        
        <h1>AdjOutFilter</h1>
        
        <p>The <var>AdjOutFilter</var> operation determines whether the system may share a payload beyond its boundaries. A payload that fails this operation must not be delivered to any inter-system peer.</p>
        
        <p>This operation must not pass unless the following conditions are all true:</p>
        
        <ol>
            <li>The value of <var>attributes.share</var> must not be <var>false</var>.</li>
        </ol>
        
        <p>An implementation may define additional criteria for this operation.</p>
            
        <section data-requirement="should" data-status="stub">

            <h1>AdjOutFilterRules</h1>
            
            <p>The <var>AdjOutFilterRules</var> structure may be implemented as a methodology for specifying filter rules.</p>
            
            <section data-status="non-normative">
                
                <p>While implementations may add AdjOutFilter constraints internally, this structure is useful for allowing outlet- or user- defined rules, such as via the <a href="module/manager#OutletReceiveAdjOutFilterRules"><var>OutletReceiveAdjOutFilterRules</var> (Manager Module)</a> operation.</p>
                
            </section>

        </section>
        
    </section>
    
    <section data-requirement="must">
        
        <h1>AdjOutTranslate</h1>
        
        <p>The <dfn>AdjOutTranslate</dfn> operation accepts a <a href="module/payload#localpayload"><var>LocalPayload</var> (Payload Module)</a> object and converts keys in the <var>use</var> and <var>require</var> properties of the <var>original</var> section, <var>attributes</var> section, if defined, and the array elements of the <var>journal</var> section, if defined, into their proper UUID.</p>
        
        <p data-status="non-normative">This operation is the inverse of <a href="module/receiver#adjintranslate"><var>AdjInTranslate</var> (Receiver Module)</a>.</p>
        
        <p data-status="non-normative">While it may be more useful intra-system to use a define set of strings for attribute key names, this may create namespace conflicts if more than one attribute exists for similar purpose. Consequently, inter-system communication of <var>use</var> and <var>require</var> attributes must use UUIDs from the corresponding <a href="core#attribute-specifications">attribute specifications</a> for all key names.</p>
        
        <p>For payload <var>original</var> property, the <var>attributes</var> property (if set), and for each element in the <var>journal</var> property (if set), this operation must follow this algorithm:</p>
        
        <ol>
            <li>
                For each property in <var>use</var> property, if defined:
                <ol>
                    <li>If mapping exists from human-readable name into UUID, change key name from UUID to human-readable name;</li>
                    <li>Otherwise, if key name does not conform to RFC 4122, remove property;</li>
                    <li>Otherwise, leave key name unchanged.</li>
                </ol>
            </li>
            <li>
                 For each index in <var>require</var> property, if defined:
                <ol>
                    <li>If mapping exists from human-readable name into UUID, change key name from UUID to human-readable name;</li>
                    <li>Otherwise, if key name does not conform to RFC 4122, drop payload;</li>
                    <li>Otherwise, leave key name unchanged.</li>
                </ol>
            </li>
        </ol>
        
        <p>This operation must not share any payload with a <var>use</var> or <var>require</var> key-value pair where the key does not conform to RFC 4122. For the <var>use</var> section, it may remove the key-value pair from the object if it does not conform and then continue with the remaining attributes; for the <var>require</var> section, it must drop the entire payload and must not continue.</p>
        
        <p data-status='non-normative'>Once a payload has proceeded along the <a href='#data-path'>data path</a> and through <var>AdjOutTranslate</var>, it is ready for transmission via <a href='module/publisher#sendout'><var>SendOut</var> (Publisher Module)</a>.</p>
        
        <section data-status='non-normative'>
                    
            <h1>Implementation Example</h1>

            <pre data-lang="ruby"># Assume: payload object with:
#  - original: PayloadTransitAttributes object
#  - attributes: undefined or PayloadTransitAttributes object
#  - journal: undefined or array of PayloadTransitJournalEntry objects
# Assume: recognizes_name?(k) method returns true if human-readable to UUID mapping
# Assume: translate(k) method returns UUID mapping for human-readable name

if payload['original'].include? 'use'

  payload['original']['use'].each { |k,v|
    if recognized_name?(k)
      payload['original']['use'][translate(k)] = payload['original']['use'][k]
    end
    payload['original']['use'].delete k
  }

end

if payload['original'].include? 'require'

  payload['original']['require'].each { |k,v|
    if recognized_name?(k)
      payload['original']['require'][translate(k)] = payload['original']['use'][k]
      payload['original']['require'].delete k
    else
      unless k.match(/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/)
        raise "Mapping does not exist for 'require` attribute #{k}"
      end
    end
  }

end

if payload.include? 'attributes'

  if payload['attributes'].include? 'use'

    payload['attributes']['use'].each { |k,v|
      if recognized_name?(k)
        payload['attributes']['use'][translate(k)] = payload['attributes']['use'][k]
      end
      payload['attributes']['use'].delete k
    }

  end

  if payload['attributes'].include? 'require'

    payload['attributes']['require'].each { |k,v|
      if recognized_name?(k)
        payload['attributes']['require'][translate(k)] = payload['attributes']['use'][k]
        payload['attributes']['require'].delete k
      else
        unless k.match(/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/)
          raise "Mapping does not exist for 'require` attribute #{k}"
        end
      end
    }

  end

end

if payload.include? 'journal'

  payload['journal'].each_index { |entry_index|

    if payload['journal'][entry_index].include? 'use'

      payload['journal'][entry_index]['use'].each { |k,v|
        if recognized_name?(k)
          payload['journal'][entry_index]['use'][translate(k)] = payload['journal'][entry_index]['use'][k]
        end
        payload['journal'][entry_index]['use'].delete k
      }

    end

    if payload['journal'][entry_index].include? 'require'

      payload['journal'][entry_index]['require'].each { |k,v|
        if recognized_name?(k)
          payload['journal'][entry_index]['require'][translate(k)] = payload['journal'][entry_index]['use'][k]
          payload['journal'][entry_index]['require'].delete k
        else
          unless k.match(/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/)
            raise "Mapping does not exist for 'require` attribute #{k}"
          end
        end
      }

    end

  }

end</pre>

        </section>
        
    </section>
    
</main>
