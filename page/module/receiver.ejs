<header>
    <hgroup>
        <h2>Community App Sharing Architecture</h2>
        <h1>Receiver Module</h1>
    </hgroup>
</header>

<footer>
    
    <section>
        <h1>Status of this Memo</h1>
        <p>This memorandum specifies the CASA Protocol Receiver Module, which defines how to make inter-system queries to retrieve payloads. The specification outlined forthwith is a work in progress and not intended for production use at this time. Distribution of this memo is unlimited.</p>
    </section>
    
    <section>
        <h1>Copyright Notice</h1>
        <p>Copyright (c) 2013, Regents of the University of California. All rights reserved.</p>
    </section>
    
    <section>
        
        <h1>Requirements</h1>
        
        <p>The following specifications must be implemented with this module:</p>
        
        <dl>
            <dt><a href="core">CASA Protocol Core</a></dt>
            <dd>Must implement basic protocol definition.</dd>
            <dt><a href="module/payload#transitpayload">CASA Protocol Payload Module - TransitPayload</a></dt>
            <dd>Must implement TransitPayload with journal attribute.</dd>
            <dt><a href="module/payload#localpayload">CASA Protocol Payload Module - LocalPayload</a></dt>
            <dd>Must implement LocalPayload; should implement with original attribute; may implement with journal attribute.</dd>
        </dl>
        
    </section>
    
    <section>
        
        <h1>Terminology</h1>
        <p>The key words <strong>must</strong>, <strong>must not</strong>, <strong>required</strong>, <strong>shall</strong>, <strong>shall not</strong>, <strong>should</strong>, <strong>should not</strong>, <strong>recommended</strong>, <strong>may</strong>, and <strong>optional</strong> in this document are to be interpreted as described by <strong><a href="http://tools.ietf.org/rfc/rfc2119.txt" rel="external">RFC 2119</a></strong> ["Key words for use in RFCs to Indicate Requirement Levels"].</p>
        <p>The key words <strong>HTTP request</strong>, <strong>HTTP response</strong>, <strong>HTTP GET request</strong>, <strong>HTTP Response Status Code</strong> (alternatively: <strong>response status</strong>), <strong>Client Error 4xx</strong> (alternatively: <strong>4xx Error</strong>) and <strong>Server Error 5xx</strong> (alternatively: <strong>5xx Error</strong>) in this document is to be interpreted as described by <strong><a href="http://tools.ietf.org/rfc/rfc2616.txt" rel="external">RFC 2616</a></strong> ["Hypertext Transfer Protocol -- HTTP/1.1"].</p>
        <p>The key word <strong>exponential backoff</strong> in this document is to be interpreted as described by <strong><a href="http://tools.ietf.org/rfc/rfc2988.txt" rel="external">RFC 2988</a></strong> ["Computing TCP's Retransmission Timer"].</p>
        
    </section>
    
</footer>

<main>
    
    <section>
        
        <h1>Process Flow</h1>
        
        <p>To receive a payload from a peering system:</p>
        
        <ol>
            <li>Issue an <var>HTTP GET /payloads</var> request; may include a secret.
            </li>
            <li>
                Must validate response.
                <ol>
                    <li>If invalid <var>Content-Type</var>, abort.</li>
                    <li>If response body is not valid JSON array, abort.</li>
                    <li>If an element of JSON array is not valid <a href="module/payload#transitpayload"><var>TransitPayload</var> (Payload Module)</a>, discard element</li>
                </ol>
            </li>
            <li>
                For each valid <a href="module/payload#transitpayload"><var>TransitPayload</var> (Payload Module)</a>:
                <ol>
                    <li>Must translate via <a href="#adjintranslate"><var>AdjInTranslate</var></a>;</li>
                    <li>Must squash via <a href="#adjinsquash"><var>AdjInSquash</var></a>;</li>
                    <li>Must pass filtering by <a href="#adjintfilter"><var>AdjInFilter</var></a>; may filter with custom rules;</li>
                    <li>May store within <a href="#adjinstore"><var>AdjInStore</var></a>.</li>
                </ol>
            </li>
        </ol>
        
        <p>Upon successful completion of this process flow, a system shall have produced a set of valid <a href="module/payload#localpayload"><var>LocalPayload</var> (Payload Module)</a> objects from a peering system.</p>
        
    </section>
    
    <section data-requirement="must">
        
        <h1>ReceiveIn</h1>
        
        <p>The <dfn>ReceiveIn</dfn> operation performed by a system ("client") queries payloads from a peering system ("host") by way of an HTTP request and response. The queried system must implement the <a href="module/publisher">Publisher Module</a> for this operation to succeed.</p>
        
        <section>
            
            <h1>Request</h1>
            
            <p>The client must issue an HTTP GET request to the <var>/payloads</var> route of the peering system.</p>
            
            <p>The client may include a request body. If it includes a request body, it must be JSON-formatted.</p>
            
            <p data-status="non-normative">A request body is used to specify a secret in the event that the host implements access controls. This secret may also be specified in the query string of the GET request.</p>
            
            <p>The following headers are relevant to this request:</p>
            
            <dl>
                <dt><var>Accept: application/json</var></dt>
                <dd>The client should send this header, although it may be implied by omission. The client must not send any other <var>Accept</var> header.</dd>
                <dt><var>Accept-Charset: utf-8</var></dt>
                <dd>The client may send this header, although it may be implied by omission. The client must not send any other <var>Accept-Charset</var> header.</dd>
                <dt><var>Accept-Encoding</var></dt>
                <dd>The client may send this header with acceptable encodings. The host may implement an encoding, but the client must be prepared to accept a non-encoded response.</dd>
                <dt><var>Content-Type: application/json</var></dt>
                <dd>The client must send this header if the request includes a body section, although it may be implied by omission. The client must not send any other <var>Content-Type</var> header.</dd>
            </dl>
            
        </section>
        
        <section>
        
            <h1 data-ref="receivein-success-response">Success Response</h1>
            
            <p>A successful response is denoted by a 200 OK.</p>
            
            <p>When a client receives a 200 OK response, it must validate the message body. Validation passes if:</p>

            <ol>
                <li>The response should have a <var>Content-Type</var> header of <var>application/json</var>, although it may be implied by omission. If the response is of other <var>Content-Type</var>, the entire response must be discarded.</li>
                <li>Message body must be valid JSON. If this condition fails, the entire response must be discarded.</li>
                <li>Message body must be an array. If this condition fails, the entire response must be discarded.</li>
                <li>Each element of the array must conform to the TransitPayload JSON Schema. If this condition fails, the non-conforming element must be discarded, but the client may still process conforming elements.</li>
            </ol>
            
            <p data-status="non-normative">Consult <a href="#process-flow">Process Flow</a> for the operations that must be performed against <var>TransitPayload</var> objects received via this operation.</p>
        
        </section>
        
        <section>
            
            <h1>Error Response</h1>
            
            <p>An error response is denoted by 4xx Error or 5xx Error.</p>
            
            <p>Except for the 404 Error status code, the client must not send an identical request after receiving a 4xx Error; however, it may attempt to resolve the issue by modifying the request headers and body:</p>
            
            <dl>
                <dt><var>400 Bad Request</var></dt>
                <dd>The client may correct the JSON format of the request body and try again.</dd>
                <dt><var>403 Unauthorized</var></dt>
                <dd>The client may add a secret to the query string or request body and try again (see <a href=#receivein-access-controls">ReceiveIn with Access Controls</a>).</dd>
                <dt><var>406 Not Acceptable</var></dt>
                <dd>The client may correct the <var>Accept</var> and <var>Accept-Charset</var> headers and try again.</dd>
                <dt><var>415 Unsupported Media Type</var></dt>
                <dd>The client may correct the <var>Accept</var> and <var>Accept-Charset</var> headers and try again.</dd>
            </dl>
            
            <p>The client may send an identical request after receiving a 5xx Error; additionally, the client may send an identical request after receiving a 404 Error if the client administrator confirms the host is willing to serve the route. If the client sends an identical request, it should use exponential backoff.</p>
            
            <p data-status="non-normative">5xx Error responses (and 404 Error responses when a host is known to fulfill a route) are commonly sent because the host is overcapacity, unavailable or encountering internal errors. Exponential backoff lessens the load on a host and allows host administrator to resolve availability and internal logic errors.</p>
            
        </section>
        
    </section>
        
    <section data-requirement="may">

        <h1 data-ref="receivein-access-controls">ReceiveIn with Access Controls</h1>

        <p>A host may refuse to serve <var>GET /payloads</var> requests unless certain access criteria are met. If the client does not meet the host's access criteria, the HTTP response should be a 403 Error, and it must be within the 4xx Error and 5xx Error ranges.</p>
        
        <section data-status='non-normative'>
            
            <p><a href='module/publisher#sendout-access-controls'>SendOut with Access Controls (Publisher Module)</a> specifies two kinds of access control: <var>address-based</var> and <var>secret-based</var>. The former requires that a host must not respond to any request unless it matches a certain IP address or range, while the latter requires that the client provide a pre-negotiated <var>secret</var> property either via the query string or a JSON-encoded request body.</p>
            
        </section>
        
        <p>If the client has negotiated a <var>secret</var> parameter with the host, it must send this property either by the name <var>secret</var> within the query string or as a property <var>secret</var> within a JSON-encoded object in the request body.</p>

        <section data-requirement="should">

            <h1 data-ref="adjoutpeer">AdjInPeer</h1>

            <p>The <dfn>AdjInpeer</dfn> structure may be implemented to define access requirements.</p>
            
            <p data-status="non-normative">This structure is useful when managing a number of in-bound peers that the host queries. This structure is implemented for access controls in the <a href="module/manager#OutletReceiveNode"><var>OutletReceiveNode (Manager Module)</var></a> operation.</p>

            <section data-status="conflict" data-message="The path default should be empty string, and path should not be allowed to end with a slash as all routes already include a leading slash.">
                
                <h1>Schema</h1>
            
                <pre data-schema="AdjInPeer"></pre>
            
            </section>
            
            <section data-status='non-normative'>
                    
                <h1>Usage Example</h1>

                <pre data-lang="ruby"># Assume: adjInPeers array of AdjInPeer objects
# Assume: Net::HTTP::Get and Net::HTTP classes
# Assume: process_response(response) method that:
#  - validates response
#  - runs AdjInTranslate -> AdjInSquash -> AdjInFilter
#  - optionally stores in AdjInStore

adjInPeers.each { |peer|

  hostname  = peer['out']['hostname']
  scheme    = peer['out'].include?('scheme') ? peer['out']['scheme'] : 'https'
  path      = peer['out'].include?('path') ? peer['out']['path'] : ''
  port      = peer['out'].include?('port') ? peer['out']['port'] : ( scheme == 'https' ? 443 : 80 )

  request = Net::HTTP::Get.new(path+"/payloads")

  request.add_field('Accept', 'application/json')
  request.add_field('Accept-Charset', 'utf-8')
  request.add_field('Content-Type', 'application/json')

  if peer['out'].include? 'secret'
    request.body = {'secret'=>secret}.to_json
  end

  response = Net::HTTP.new(hostname, port).request(request)

  process_response(response)

}</pre>

            </section>

        </section>

    </section>
    
    <section data-requirement="must">
        
        <h1>AdjInTranslate</h1>
        
        <p>The <var>AdjInTranslate</var> operation accepts a <a href="module/payload#transitpayload"><var>TransitPayload</var> (Payload Module)</a> object and converts recognized keys in the <var>use</var> and <var>require</var> properties of the <var>original</var> section and the array elements of the <var>journal</var> section, if defined, into human-readable keys.</p>
        
        <p data-status="non-normative">While all <var>use</var> and <var>require</var> keys in <a href="module/payload#transitpayload"><var>TransitPayload</var> (Payload Module)</a> objects must be encoded as machine-readable UUIDs corresponding to <a href="core#attribute-specifications">Attribute Specifications (Core)</a>, working directly with UUIDs is considered cumbersome for system maintenance. This operation thus allows for intra-system treatment of attributes under a common name. This is especially useful for <a href="module/local#outlet"><var>Outlets</var> (Local Module)</a>, which are administered by human users who prefer human-readable names.</p>
                
        <p>For payload <var>original</var> property and, if set, for each element in the <var>journal</var> property, this operation must follow this algorithm:</p>
        
        <ol>
            <li>
                For each property in <var>use</var> property, if defined, and for each index in <var>require</var> property, if defined:
                <ol>
                    <li>If mapping exists from UUID to human-readable name, change key name from UUID to human-readable name;</li>
                    <li>Otherwise, leave key name unchanged.</li>
                </ol>
            </li>
        </ol>
        
        <section data-status='non-normative'>
                    
            <h1>Implementation Example</h1>

            <pre data-lang="ruby"># Assume: payload object with:
#  - original: PayloadTransitAttributes object
#  - journal: undefined or array of PayloadTransitJournalEntry objects
# Assume: recognizes?(k) method returns true if UUID to human-readable mapping
# Assume: translate(k) method returns human-readable mapping for UUID

['use', 'require'].each { |type|
  
  if payload['original'].include? type

    payload['original'][type] = Hash[payload['journal'][type].map { |k,v|
        [ recognizes?(k) ? translate(k) : k, v ]
    }]

  end

  if payload.include? 'journal'

    payload['journal'].each_index { |index|

      if payload['journal'][index].contains? type

        payload['journal'][index][type] = Hash[payload['journal'][index][type].map { |k,v|
            [ recognizes?(k) ? translate(k) : k, v ]
        }]

      end
    }

  end

}</pre>

        </section>
        
    </section>
    
    <section data-requirement="must">
        
        <h1>AdjInSquash</h1>
        
        <p>The <var>AdjInTranslate</var> operation accepts a <a href="module/payload#transitpayload"><var>TransitPayload</var> (Payload Module)</a> object that must have already been passed through <a href='#adjintranslate'><var>AdjInTranslate</var></a>, and it produces an <a href='#module/payload#localpayload'><var>LocalPayload</var> (Payload Module)</a> by constructing an <var>attributes</var> section from the <var>original</var> property and optionally the <var>journal</var> section if defined.</p>
        
        <p>This operation must following this algorithm:</p>
        
        <ol>
            <li>If <var>attributes</var> property already exists, discard it.</li>
            <li>Copy <var>original</var> property into new <var>attributes</var> property.</li>
            <li>If <var>journal</var> is defined, for each entry sequentially in the <var>journal</var> section:
                <ol>
                    <li>For each property in <var>use</var> property, if defined, and for each index in <var>require</var> property, if defined:
                        <ol>
                            <li>Apply property into respective section of <var>attributes</var></li>
                        </ol>
                    </li>
                </ol>
            </li>
        </ol>
        
        <p>An <a href='core#attribute-specification'>Attribute Specification</a> may define custom rules for how (3)(a)(i) is performed. If an attribute specification does not define custom rules, the value must be copied directly from the entry into the attribute section by key name.</p>
        
        <section data-status='non-normative'>
                    
            <h1>Implementation Example</h1>

            <pre data-lang="ruby"># Assume: payload object with:
#  - original: PayloadTransitAttributes object
#  - journal: undefined or array of PayloadTransitJournalEntry objects
# Assume: custom_apply_attributes?(key) returns true if custom operation for key
# Assume: apply_attributes(key, payload, value) method applies the value to 
#                  payload attribute by key with custom operation defined by key

payload['attributes'] = payload['original']

if payload.include? 'journal'

  ['use','require'].each { |type|

    payload['journal'].each { |entry|

      entry.each { |key, value|

        if custom_apply_attributes? key
          apply_attributes(key, payload, value) 
        else
          payload['attributes'][key] = value
        end

      }

    }

  }

end</pre>

        </section>
        
    </section>
    
    <section data-requirement="must">
        
        <h1>AdjInFilter</h1>
        
        <p>The <var>AdjInFilter</var> operation determines whether the system may process a <a href="module/payload#localpayload"><var>LocalPayload</var> (Payload Module)</a> object. A payload that fails this operation must not be delivered to any intra-system outlet or shared with any inter-system peer.</p>
        
        <p>This operation must not pass unless the following conditions are all true:</p>
        
        <ol>
            <li>All keys under <var>attributes.require</var> must be recognized.</li>
            <li>All key-value pairs under <var>attributes.require</var> must validate per the <a href='core#attribute-specification'>attribute specification</a> referred to by key.</li>
            <li>If <a href='#adjinstore'><var>AdjInStore</var></a> is implemented and a payload matching <var>identity</var> already exists in persistence, <var>attributes.timestamp</var> must be more recent than the value in persistence.</li>
        </ol>
        
        <p>An implementation may define additional criteria for this operation.</p>

        <section data-requirement="should" data-status="stub">

            <h1>AdjInFilterRules</h1>

            <p>The <dfn>AdjInFilterRules</dfn> structure may be implemented as a methodology for specifying filter rules.</p>
            
            <p data-status="non-normative">While implementations may add <var>AdjInFilter</var> constraints internally, this structure is useful for allowing outlet- or user- defined rules, such as via the <a href="module/manager#OutletReceiveAdjInFilterRules"><var>OutletReceiveAdjInFilterRules (Manager Module)</var></a> operation.</p>

        </section>
        
    </section>
    
    <section data-requirement="may">
        
        <h1>AdjInStore</h1>
        
        <p>The <dfn>AdjInStore</dfn> structure is a persistent data store that contains <a href='module/payloads#localpayload'><var>LocalPayload</var> (Payload Module)</a> objects. A payload stored in this structure must be received via <a href='#receivein'><var>ReceiveIn</var></a>, translated by <a href='#adjintranslate'><var>AdjInTranslate</var></a>, squashed by <a href='#adjinsquash'><var>AdjInSquash</var></a> and filtered by <a href='#adjintranslate'><var>AdjInFilter</var></a>.</p>
        
        <p data-status='non-normative'>This structure is used by the <a href='module/relay'>Relay Module</a> to generate payloads for inter-system propagation to peers; additionally, this structure is used by the <a href='module/local'>Local Module</a> to present inter-system payloads to intra-system outlets. Both modules use this structure with additional constraints before presenting payloads, so the payloads in this structure are never accessed directly by inter-system peers or intra-system outlets.</p>
        
        <section data-requirement='must'>
            
            <h1>Required Operations</h1>
        
            <p>This structure must support two operations:</p>

            <dl>
                <dt data-ref='adjinstore-create'>AdjInStore::create(LocalPayload)</dt>
                <dd>Stores a new record in persistence; must not create a record if any record already exists in persistence with the same <var>identity</var> as the new record.</dd>
                <dt data-ref='adjinstore-get'>AdjInStore::get(PayloadIdentity)</dt>
                <dd>Gets a record from persistence that matches the <a href='module/payload#payloadidentity'><var>PayloadIdentity</var> (Payload Module)</a> passed to this method; must return false if no payload exists matching identity.</dd>
            </dl>
        
            <p data-status='non-normative'>This structure will not store two payloads with identical <var>identity</var> sections.</p>
            
            <p>The <var>create</var> operation must not be used in any way except as defined by this protocol and its modules.</p>
            
            <p data-status='non-normative'>To add a payload for propagation via <a href='module/publisher#sendout'><var>SendOut</var> (Publisher Module)</a>, it must either arrive via <var>ReceiveIn</var> or be added to <a href='module/local#localstore'><var>LocalStore</var> (Local Module)</a>. It must not be added directly to <var>AdjInStore</var>, as this implies that the payload arrived from an external source.</p>
        
        </section>
        
        <section data-requirement='should'>
            
            <h1>Additional Operations</h1>
        
            <p>This structure should support two additional operations:</p>
        
            <dl>
                <dt data-ref='adjinstore-update'>AdjInStore::update(LocalPayload)</dt>
                <dd>Updates an existing payload record in persistence; must identify the payload to update by finding an existing record in persistence with the same <var>identity</var> attribute.</dd>
                <dt data-ref='adjinstore-get'>AdjInStore::delete(PayloadIdentity)</dt>
                <dd>Deletes a record from persistence that matches the <a href='module/payload#payloadidentity'><var>PayloadIdentity</var> (Payload Module)</a> passed to this method.</dd>
            </dl>
            
            <p>The <var>update</var> and <var>delete</var> operations must not be used in any way except as defined by this protocol and its modules.</p>
            
            <p data-status='non-normative'>To change the way a payload is presented via <a href='module/publisher#sendout'><var>SendOut</var> (Publisher Module)</a>, use <a href='module/relay#adjouttransform'><var>AdjOutTransform</var> (Relay Module)</a>. To change the way a payload is presented via <a href='module/local#sendlocal'><var>SendLocal</var> (Local Module)</a>, use <a href='module/local#adjintransform'><var>AdjInTransform</var> (Local Module)</a>.</p>
        
            <p>The <var>delete</var> operation must be used to prune out stale entries.</p>
            
            <p data-status='non-normative'>To prevent a payload from being presented via <a href='module/publisher#sendout'><var>SendOut</var> (Publisher Module)</a>, use <a href='module/relay#adjoutfilter'><var>AdjOutFilter</var> (Relay Module)</a>. A payload may not be prevented from being presented via <a href='module/local#sendlocal'><var>SendLocal</var> (Local Module)</a> unless it is dropped by <a href='#adjinfilter'><var>AdjInFilter</var> prior to this step. This means that a payload must not be relayed via <a href='module/publisher#sendout'><var>SendOut</var> (Publisher Module)</a> unless it is also made available via <a href='module/local#sendlocal'><var>SendLocal</var> (Local Module)</a>.</p>
            
        </section>
        
    </section>
    
</main>